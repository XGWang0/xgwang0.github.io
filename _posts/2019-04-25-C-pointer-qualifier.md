---
layout: post
title:  "C 指针限定符 const volatile restrict"
categories: C
tags:  C 
author: Root Wang
---

* content
{:toc}

### volatile

volatile是一个类型修饰符，它的主要作用是防止编译器进行优化。那么什么是编译器优化呢，我们看两个个例子：

例1： 
```c
x = 0x04;
x = 0x06;
x = 0x08;
```
对于硬件来说这是3条指令，依次执行，但是如果让编译器进行编译，则它会忽略前面两条语句，直接得到 x = 0x08；
```c
int i = 5, j, k;
j = i;
k = i;
```
编译器进行编译时，由于i在第二条和第三条语句之间没有作为左值存在，所以第三条语句k=i；并没有真正到i所在的内存区域去取得i的值，而是直接取第二条语句保存在寄存器中的副本。


### restrict

restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问该对象唯一且初始的方式。要弄明白为什么这样做有用，先看几个例子。考虑下面的代码：

```c
int ar[10];
int * restrict restar= (int *) malloc(10 * sizeof(int));
int * par= ar;
```

这里，指针restar是访问由malloc()所分配的内存的唯一且初始的方式。因此，可以用restrict关键字限定它。而指针par既不是访问ar数组中数据的初始方式，也不是唯一方式。所以不用把它设置成restrict。

现在考虑下面稍微复杂的例子，其中n是int类型：

```c
for (n=0; n<10; n++)
  {
    par[n]+=5;
    restar[n] +=5;
    ar[n] *=2;
    par[n] +=3;
    restar[n] +=3;
  }
```

由于之前声明了restar是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及restar的两条语句替换成下面的语句，效果相同：
```c
restar[n] +=8;/*可以进行替换*/
```
但是，如果把与par相关的两条语句替换成下面的语句，将导致计算错误：
```c
par[n] +=8;/*将给出错误的结果*/
```
这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。

在本例中，如果未使用restrict关键字，编译器必须假定最坏的情况（即，两次使用指针之间，其他的标识符可能已经改变了该数据）。如果用了restrict关键字，编译器就可以选择捷径优化计算。

restrict限定符还可以用于函数形参中的指针。这意味着编译器可以假定该函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。例如，C库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是：

```c
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
void *memmove(void * s1, const void * s2,size_t n);
```
这两个函数都从位置s2把n个字节拷贝到位置s1。memcpy()函数要求两个位置不重叠，但是memove()没有这样的要求。声明s1和s2为restrict说明这两个指针是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这满足memcpy()函数无重叠的要去。memmove()允许重叠，它在拷贝数据时不得不更小心，以防止在使用数据之前就先覆盖了数据。

总结
restrict关键字有两个读者。一个是编译器，该关键字告诉编译器可以自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足restrict要求的参数，总而言之，编译器不会检查用户是否遵循这一限制，但是无是它可能产生严重后果。
